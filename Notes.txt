    The purpose of this file is to prep notes that may not be
    ready for a entry in the repository issues tracker. We should
    make some attempt to coordinate the two, with a issue number
    here once it gets tracked, and a line from here in the tracker
    to label it.

    I'd prefer to keep this file small and use it only during the
    transition from personal note-taking to repo issue tracking.

Project: Move Adapton to new repository
=======================================
Main goals:
1) Mininal code base
2) experiments.ml works
3) Create opam package
4) Run code from package
===== Complete =====

===== Continuing =====

STATUS:

  AS2 not working
  Gran not working (_nm functions?)

TODO:

Major:
  (issue 2)Update AS2 to Grifola
  (issue 3)implement basic list mergesort (with contract-reduce)
  (issue 4)create an oo interface to encapsulate data types (discussed below)
  Expand alternative Artlib modules
  Test out granularity control


Minor:
  Use _tags for internal dependency
  (issue 5)move install script to makefile (findlib install [deps])
  Remove non-working code
  (issue 6)fix title line of experiments
  (issue 7)include a 'compare' item to the datatypes
  (issue 8)get the logging to work
  (issue 9)have experiments.ml measure initial list creation, not just forcing it

Determine:
  mutual recursion strategy
    compiler doesn't allow: let memo1 (params) = ... and memo2 (params) = ... in
  a better articulation strategy for datastructures



========== Discussion ==========

Singleton questions:

  do .thunk and .cell really need names?
    they can be beneficial, but it may be better to create
    a namespace for any complex programming

  can the name just be a hash of the code plus inputs?
    no, the point is location in datastructure

  can or should there be one memotable per structure?

  how do you set up a new memotable?
    create an artType - table of data
    create a memoized function - table of code
    more?

  since tables are given names, is there a global table that memo matches memotables?
    possibly, but unimplemented

  what's the difference between DatType memos and memo funcions
    DatType is value or return type, functions are code with parameter and return type

  how do you set up thunks to simulate a recursive call? (is it even important)
    simulation with thunks is possible, but will not memo match properly
    functional techniques and extra parameters should avoid this issue

  why do mfn's have all the modules available?

OO Interface:
  thunk as primitives, memo as constructor
  all thunks have hypothetical mode
  cell = thunk fun->default

  class 'a IResult:
    #get():'a                      forces computation
    #try(val:'a):()                will ignore computation and pass val to dependents
    #reset():()                    returns computation to default
    #type():DatType with t = 'a    gets the type module

  since modules that need to be included are all datatypes,
  we can be more explicit about it:

  IComp ~out ~in f : 
    (type a) (type b)
    ~out:(DatType with type t = a) ->
    ~in:(DatType with type t = b) option ->
    (r -> b -> a) as r ->
    b -> class a IResult

  cell:  IComp ~out:AInt ~in:AUnit (fun r -> 3:int) ()
  thunk: IComp ~out:AInt ~in:AUnit (fun r -> ... a:int) ()
  memo:  IComp ~out:AInt ~in:Tuple2(a#type(), b#type()) (fun r (a,b) -> ... c:int)

  find a way to link the ~out type to the function's output type
    but we'd have an issue keeping the memotables together

  find a way to link the ~in type to the functions's input
    the issue is in creating arbitrary length parameter lists
    avoid code that constructs/deconstructs these arguments

  decide if these inputs should be premade modules or raw types
    the former allows namespace control
    the latter simplifies use

  figure out how to integrate names with the above
    name the func
    name the recursive calls
    name the result
    forking outside function call vs pairing inside function call 
    others?

Progress:
  The constructor above is just a simple wrapper on the regular
  Adapton memo function. First priority is combining type and value
  into an object to reduce code complexity. Eventually, we want to
  hide the type metadata completely. We may still need to expose it
  for object creation.

